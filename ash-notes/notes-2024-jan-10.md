# getting started with llvm

## terminology & notation

`SRC_ROOT`

This is the top level directory of the LLVM source tree.

`OBJ_ROOT`

This is the top level directory of the LLVM object tree (i.e. the tree where object files and compiled programs will be placed. It can be the same as SRC_ROOT).

## unpacking the llvm archives

If you have the LLVM distribution, you will need to unpack it before you can begin to compile it. LLVM is distributed as a number of different subprojects. Each one has its own download which is a TAR archive that is compressed with the gzip program.

The files are as follows, with x.y marking the version number:

`llvm-x.y.tar.gz`

Source release for the LLVM libraries and tools.

`cfe-x.y.tar.gz`

Source release for the Clang frontend.

# example with clang

- create `hello.c` source file:

```c
#include <stdio.h>

int main() {
  printf("hello world\n");
  return 0;
}
```

- compile into native .exe: `% clang hello.c -o hello`
- `.s` native assembly file
- `.o` native object file 
- final executable is simply named `hello`
- compile into LLVM bitcode file: 
  - `% clang -03 -emit-llvm hello.c -c -o hello.bc`
  - `-S` emits an LLVM `.ll` file (LLVM IR assembly)
  - `-c` emits an LLVM `.bc` file (LLVM bitcode file that represents LLVM IR)
  - This allows you to use the standard LLVM tools on the bitcode file
- run the program in both forms:
  - `% ./hello` 
  - `% lli hello.bc` invokes the LLVM JIT (`lli` - i for interpreter) 
- then `% llvm-dis < hello.bc | less` uses the llvm-dis utility to take a look at the bitcode
  - `llvm-dis` disassembles LLVM bitcode
  - `hello.bc` is the input (`<`) for the `llvm-dis` command
  - pipe: redirects output of this command to another command
  - `less`: a pager that allows you to view text one screen at a time when navigating thru a lot of text
- compile the program to native assembly using the LLC code generator: `% llc hello.bc -o hello.s`
  - `llc` is the LLVM static compiler command-line tool 
    - can specify the target architecture with flags so you can optimize for specific hardware
    - can also control the optimization level
  - input is `hello.bc`
  - `-o` indicates the output file
  - `hello.s` is the assembly code file
- assemble the native assembly language file into a program:
  - `% /opt/SUNWspro/bin/cc -xarch=v9 hello.s -o hello.native` (on Solaris)
  - `% gcc hello.s -o hello.native` (on others)
  - can also use clang instead of gcc, which compiles to assembly and to native and then can execute native
- execute the native code program:
  - `% ./hello.native`


# to build a project
#### https://llvm.org/docs/Projects.html#source-tree-layout

uses:
- LLVM header files
- LLVM libraries
- LLVM tools

the project will have a source tree and an object tree

source tree layout:
- lib
- include
- tools
- test

lib:
- all library source code
- for each library that you build, you will have one directory in lib w the lib's source code
- libs can be object files, archives, or dynamic libraries
- convenient place so they can all get linked later

include:
- any header files that are global to your project (used by more than one library or executable of your project)
- by placing your header files in include, they will be found automatically by the `LLVM build system`. for example, if you have a file `include/jazz/note.h`, then your source files can include it simply with `#include "jazz/note.h"`

tools:
- contains all of your source code for executables
- for each program that you build, you will have one directory in tools that contain that programs source code

test:
- regression tests
- optional package with benchmarks and programs that are known to compile with the Clang front end; (use this package for statistical information)

build order:
- lib first
- then tools




# Studying first example project

//===----------------------------------------------------------------------===//
//                         ModuleMaker Sample project
//===----------------------------------------------------------------------===//

This project is an extremely simple example of using some simple pieces of the 
LLVM API.  The actual executable generated by this project simply emits an 
LLVM bitcode file to standard output.  It is designed to show some basic 
usage of LLVM APIs, and how to link to LLVM libraries.



```cpp
//===- examples/ModuleMaker/ModuleMaker.cpp - Example project ---*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This programs is a simple example that creates an LLVM module "from scratch",
// emitting it as a bitcode file to standard out.  This is just to show how
// LLVM projects work and to demonstrate some of the LLVM APIs.
//
//===----------------------------------------------------------------------===//

#include "llvm/Bitcode/BitcodeWriter.h"
#include "llvm/IR/BasicBlock.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/InstrTypes.h"
#include "llvm/IR/Instruction.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Type.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

int main() {
  LLVMContext Context;

  // Create the "module" or "program" or "translation unit" to hold the
  // function
  Module *M = new Module("test", Context);

  // Create the main function: first create the type 'int ()'
  FunctionType *FT =
    FunctionType::get(Type::getInt32Ty(Context), /*not vararg*/false);

  // By passing a module as the last parameter to the Function constructor,
  // it automatically gets appended to the Module.
  Function *F = Function::Create(FT, Function::ExternalLinkage, "main", M);

  // Add a basic block to the function... again, it automatically inserts
  // because of the last argument.
  BasicBlock *BB = BasicBlock::Create(Context, "EntryBlock", F);

  // Get pointers to the constant integers...
  Value *Two = ConstantInt::get(Type::getInt32Ty(Context), 2);
  Value *Three = ConstantInt::get(Type::getInt32Ty(Context), 3);

  // Create the add instruction... does not insert...
  Instruction *Add = BinaryOperator::Create(Instruction::Add, Two, Three,
                                            "addresult");

  // explicitly insert it into the basic block...
  Add->insertInto(BB, BB->end());

  // Create the return instruction and add it to the basic block
  ReturnInst::Create(Context, Add)->insertInto(BB, BB->end());

  // Output the bitcode file to stdout
  WriteBitcodeToFile(*M, outs());

  // Delete the module and all of its contents.
  delete M;
  return 0;
}

```


# Breakdown

- C++ program

```cpp
// This programs is a simple example that creates an LLVM module "from scratch",
// emitting it as a bitcode file to standard out.  This is just to show how
// LLVM projects work and to demonstrate some of the LLVM APIs.
```

- creates an LLVM module 
- emit it as a bitcode file to stdout 
- demonstrates some of the LLVM APIs

- LLVM module
- `llvm/cmake/modules: build config for llvm user-defined options. checks compiler version and linker flags`
- `llvm/tools/llvm-link`: not surprisingly, links multiple LLVM modules into a single program (modules are compiler version and linker flags)
- an LLVM module is a fundamental unit of compilation in the LLVM infrastructure
- a module represents a single translation unit or source file in a program
- it consists of IR code
- each module contains functions, global variables, and other program structures
- LLVM modules can be optimized and transformed independently before being linked together to form the final executable or library
- the modular approach enables effective optimization and facilitates the development of compiler tools that operate on the LLVM IR
- in summary, a module is a container for the IR of a program, providing a basis for optimization and codegen in the LLVM compilation process


```cpp
#include "llvm/Bitcode/BitcodeWriter.h"
#include "llvm/IR/BasicBlock.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/InstrTypes.h"
#include "llvm/IR/Instruction.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Type.h"
#include "llvm/Support/raw_ostream.h"
```

- includes 12 header files:
  - 1 Bitcode BitcodeWriter
  - 10 IR files
  - 1 Support file for raw output stream

- "IR" is LLVM IR here, not abstract IR
- used for building, manipulating, and analyzing IR code

- `BasicBlock` class - basic IR block in the control flow graph
- `Constants` - declarations for constant values such as integer and floating-point constants
- `DerivedTypes` - defines derived types in IR such as arrays, pointers and structures
- `Function` class - IR function representation
- `InstrTypes` - instruction-related types
- `Instruction` class - represents a single operation in IR
- `LLVMContext` class - provides a context for various LLVM operations
- `Module` class - a collection of functions
- `Type` - defines various types such as an integer and floating-point types


## `BasicBlock`

- Control Flow Graph (CFG)
  - directed graph
  - nodes represent basic blocks
  - edges represent the flow of control between these basic blocks
  - entry node: starting point of the program
  - exit node: where program terminates or branches to other functions
- `BasicBlock`:
  - contiguous sequences of instructions in a program with a single enry point and a single exit point (no loops)
  - they are identified by labels or other markers and often consistent of a linear sequence of instructions
  - typically end with a terminator instruction that determines the next block to be executed
  - e.g. unconditional branches `br`, conditional branches `br i1 ...`, switches `switch`, and return instructions `ret`
  - loops are identified by back edges in the CFG
  - a back edge is an edge that points back to a previously visited node
  - special constructs such as `invoke` and landing pads are used to represent function calls with exception handling
  - for conditional branching, Phi nodes are used to merge values from different paths in the CFG
- CFG using `BasicBlock` is structured view of how execution can progress, allowing compilers to reason about the program's behavior and apply transformations to improve performance or generate efficient machine code (#todo: research more of that). CFG is fundamental to LLVM IR.

```cpp
using namespace llvm;
```

- a C++ directive
- brings the entire llvm namespace into scope
- therefore, prefix names not needed in the program
-  



```cpp
int main() {
  ...
  return 0; // successful program execution
  // terminated without errors
}
```

- in C++, the main program must return an int instead of being a void return like in Java


```cpp
LLVMContext Context;
```

- declares an object named `Context` of the type `LLVMContext`
- the `LLVMContext` class is part of the LLVM API and represents a context for various LLVM-related operations
- the object is created on the stack
- assuming `LLVMContext` has a default constructor (no parameters), this initializes the `Context` object using that constructor
- you can now create modules, functions, and other LLVM IR constructs


```cpp
  // Create the "module" or "program" or "translation unit" to hold the
  // function
  Module *M = new Module("test", Context);
```

- using the LLVM API to create a module
- module name is `test`
- module is a container for program definitions
- holds functions, global variables and other program-related entities
- upon initialization, dynamically allocates memory for a new module with the name test and using the Context, then returns a pointer, which we assign to `M`
- in C++, allocate with `new` and deallocate/free memory properly with `delete M;` to avoid memory leaks
- `*` declares a pointer
- `M` is the declared variable of type "pointer to Module"
- dynamic allocation means we can can reduce or increase the amount of information stored for this Context object
- "If you're using modern C++, consider using smart pointers (e.g., `std::unique_ptr`) instead of raw pointers to help manage memory automatically."


```cpp
  // Create the main function: first create the type 'int ()'
  FunctionType *FT =
    FunctionType::get(Type::getInt32Ty(Context), /*not vararg*/false);
```

- create a function type with the static method `FunctionType::get` from the `FunctionType` class
  - takes two parameters:
  - one: `Type::getInt32Ty(Context)` specifies the return type of the function, it's an `int` type, specifically an LLVM integer type of 32 bits in the given context
  - two: `/*not vararg*/false` specifies whether the function takes a variable number of arguments (variadic). here, it's set to `false`, indicating the function is not variadic
- `FunctionType *FT`: declares a pointed to a `FunctionType` object named `FT` and is assigned the function type created by `FunctionType::get`
- summary: this is setting up the type information for the main function signature of parameter types and return type. because it is false to variadic, the main function takes no parameters: `int main()`.
- then set up basic blocks and define instructions within those blocks to implement the logic of the program