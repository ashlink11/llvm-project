# getting started with llvm

## terminology & notation

`SRC_ROOT`

This is the top level directory of the LLVM source tree.

`OBJ_ROOT`

This is the top level directory of the LLVM object tree (i.e. the tree where object files and compiled programs will be placed. It can be the same as SRC_ROOT).

## unpacking the llvm archives

If you have the LLVM distribution, you will need to unpack it before you can begin to compile it. LLVM is distributed as a number of different subprojects. Each one has its own download which is a TAR archive that is compressed with the gzip program.

The files are as follows, with x.y marking the version number:

`llvm-x.y.tar.gz`

Source release for the LLVM libraries and tools.

`cfe-x.y.tar.gz`

Source release for the Clang frontend.

# example with clang

- create `hello.c` source file:

```c
#include <stdio.h>

int main() {
  printf("hello world\n");
  return 0;
}
```

- compile into native .exe: `% clang hello.c -o hello`
- `.s` native assembly file
- `.o` native object file 
- final executable is simply named `hello`
- compile into LLVM bitcode file: 
  - `% clang -03 -emit-llvm hello.c -c -o hello.bc`
  - `-S` emits an LLVM `.ll` file (LLVM IR assembly)
  - `-c` emits an LLVM `.bc` file (LLVM bitcode file that represents LLVM IR)
  - This allows you to use the standard LLVM tools on the bitcode file
- run the program in both forms:
  - `% ./hello` 
  - `% lli hello.bc` invokes the LLVM JIT (`lli` - i for interpreter) 
- then `% llvm-dis < hello.bc | less` uses the llvm-dis utility to take a look at the bitcode
  - `llvm-dis` disassembles LLVM bitcode
  - `hello.bc` is the input (`<`) for the `llvm-dis` command
  - pipe: redirects output of this command to another command
  - `less`: a pager that allows you to view text one screen at a time when navigating thru a lot of text
- compile the program to native assembly using the LLC code generator: `% llc hello.bc -o hello.s`
  - `llc` is the LLVM static compiler command-line tool 
    - can specify the target architecture with flags so you can optimize for specific hardware
    - can also control the optimization level
  - input is `hello.bc`
  - `-o` indicates the output file
  - `hello.s` is the assembly code file
- assemble the native assembly language file into a program:
  - `% /opt/SUNWspro/bin/cc -xarch=v9 hello.s -o hello.native` (on Solaris)
  - `% gcc hello.s -o hello.native` (on others)
  - can also use clang instead of gcc, which compiles to assembly and to native and then can execute native
- execute the native code program:
  - `% ./hello.native`


# to build a project
#### https://llvm.org/docs/Projects.html#source-tree-layout

uses:
- LLVM header files
- LLVM libraries
- LLVM tools

the project will have a source tree and an object tree

source tree layout:
- lib
- include
- tools
- test

lib:
- all library source code
- for each library that you build, you will have one directory in lib w the lib's source code
- libs can be object files, archives, or dynamic libraries
- convenient place so they can all get linked later

include:
- any header files that are global to your project (used by more than one library or executable of your project)
- by placing your header files in include, they will be found automatically by the `LLVM build system`. for example, if you have a file `include/jazz/note.h`, then your source files can include it simply with `#include "jazz/note.h"`

tools:
- contains all of your source code for executables
- for each program that you build, you will have one directory in tools that contain that programs source code

test:
- regression tests
- optional package with benchmarks and programs that are known to compile with the Clang front end; (use this package for statistical information)

build order:
- lib first
- then tools




# Studying first example project

//===----------------------------------------------------------------------===//
//                         ModuleMaker Sample project
//===----------------------------------------------------------------------===//

This project is an extremely simple example of using some simple pieces of the 
LLVM API.  The actual executable generated by this project simply emits an 
LLVM bitcode file to standard output.  It is designed to show some basic 
usage of LLVM APIs, and how to link to LLVM libraries.



```cpp
//===- examples/ModuleMaker/ModuleMaker.cpp - Example project ---*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This programs is a simple example that creates an LLVM module "from scratch",
// emitting it as a bitcode file to standard out.  This is just to show how
// LLVM projects work and to demonstrate some of the LLVM APIs.
//
//===----------------------------------------------------------------------===//

#include "llvm/Bitcode/BitcodeWriter.h"
#include "llvm/IR/BasicBlock.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/InstrTypes.h"
#include "llvm/IR/Instruction.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Type.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

int main() {
  LLVMContext Context;

  // Create the "module" or "program" or "translation unit" to hold the
  // function
  Module *M = new Module("test", Context);

  // Create the main function: first create the type 'int ()'
  FunctionType *FT =
    FunctionType::get(Type::getInt32Ty(Context), /*not vararg*/false);

  // By passing a module as the last parameter to the Function constructor,
  // it automatically gets appended to the Module.
  Function *F = Function::Create(FT, Function::ExternalLinkage, "main", M);

  // Add a basic block to the function... again, it automatically inserts
  // because of the last argument.
  BasicBlock *BB = BasicBlock::Create(Context, "EntryBlock", F);

  // Get pointers to the constant integers...
  Value *Two = ConstantInt::get(Type::getInt32Ty(Context), 2);
  Value *Three = ConstantInt::get(Type::getInt32Ty(Context), 3);

  // Create the add instruction... does not insert...
  Instruction *Add = BinaryOperator::Create(Instruction::Add, Two, Three,
                                            "addresult");

  // explicitly insert it into the basic block...
  Add->insertInto(BB, BB->end());

  // Create the return instruction and add it to the basic block
  ReturnInst::Create(Context, Add)->insertInto(BB, BB->end());

  // Output the bitcode file to stdout
  WriteBitcodeToFile(*M, outs());

  // Delete the module and all of its contents.
  delete M;
  return 0;
}

```


# Breakdown

- C++ program

```cpp
// This programs is a simple example that creates an LLVM module "from scratch",
// emitting it as a bitcode file to standard out.  This is just to show how
// LLVM projects work and to demonstrate some of the LLVM APIs.
```

- creates an LLVM module 
- emit it as a bitcode file to stdout 
- demonstrates some of the LLVM APIs

- LLVM module
- `llvm/cmake/modules: build config for llvm user-defined options. checks compiler version and linker flags`
- `llvm/tools/llvm-link`: not surprisingly, links multiple LLVM modules into a single program (modules are compiler version and linker flags)
- an LLVM module is a fundamental unit of compilation in the LLVM infrastructure
- a module represents a single translation unit or source file in a program
- it consists of IR code
- each module contains functions, global variables, and other program structures
- LLVM modules can be optimized and transformed independently before being linked together to form the final executable or library
- the modular approach enables effective optimization and facilitates the development of compiler tools that operate on the LLVM IR
- in summary, a module is a container for the IR of a program, providing a basis for optimization and codegen in the LLVM compilation process



